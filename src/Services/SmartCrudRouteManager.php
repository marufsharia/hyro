<?php

namespace Marufsharia\Hyro\Services;

use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

/**
 * Smart CRUD Route Manager
 * 
 * Manages CRUD routes with automatic file creation and smart loading.
 * Routes are always loaded from application root (routes/hyro/crud.php).
 * 
 * @package Marufsharia\Hyro\Services
 */
class SmartCrudRouteManager
{
    /**
     * CRUD route file path (always in application root)
     */
    protected string $routeFilePath;

    /**
     * Route file template
     */
    protected string $routeTemplate = <<<'PHP'
<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Hyro CRUD Routes
|--------------------------------------------------------------------------
|
| This file contains auto-generated CRUD routes.
| Routes are automatically registered when you create CRUD resources.
|
| DO NOT EDIT THIS FILE MANUALLY - Changes will be overwritten!
| Use 'php artisan hyro:discover-routes' to regenerate.
|
*/

Route::prefix(config('hyro.admin.route.prefix', 'admin/hyro'))
    ->middleware(config('hyro.admin.route.middleware', ['web', 'auth']))
    ->name('hyro.admin.')
    ->group(function () {
        // CRUD routes will be auto-generated below
        // {{ routes }}
    });

PHP;

    public function __construct()
    {
        $this->routeFilePath = base_path('routes/hyro/crud.php');
    }

    /**
     * Get the CRUD route file path.
     *
     * @return string
     */
    public function getRouteFilePath(): string
    {
        return $this->routeFilePath;
    }

    /**
     * Check if CRUD route file exists.
     *
     * @return bool
     */
    public function routeFileExists(): bool
    {
        return File::exists($this->routeFilePath);
    }

    /**
     * Create CRUD route file if it doesn't exist.
     *
     * @return bool
     */
    public function ensureRouteFileExists(): bool
    {
        if ($this->routeFileExists()) {
            return true;
        }

        // Create directory if it doesn't exist
        $directory = dirname($this->routeFilePath);
        if (!File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        // Create route file with template
        File::put($this->routeFilePath, $this->routeTemplate);

        return true;
    }

    /**
     * Add a CRUD route to the route file.
     *
     * @param string $resourceName
     * @param string $componentClass
     * @param array $options
     * @return bool
     */
    public function addRoute(string $resourceName, string $componentClass, array $options = []): bool
    {
        $this->ensureRouteFileExists();

        $routeName = Str::kebab(Str::plural($resourceName));
        $routePath = $options['path'] ?? $routeName;
        $middleware = $options['middleware'] ?? [];
        $permission = $options['permission'] ?? Str::kebab($resourceName);
        $isFrontend = $options['frontend'] ?? false;
        $requiresAuth = $options['auth'] ?? true;

        // For frontend routes, check if path is available
        if ($isFrontend) {
            if ($this->isRoutePathTaken($routePath)) {
                // Generate alternative path
                $routePath = $this->generateAvailableRoutePath($routePath);
            }
        }

        // Generate route definition
        $routeDefinition = $this->generateRouteDefinition(
            $routePath,
            $componentClass,
            $routeName,
            $middleware,
            $permission,
            $isFrontend,
            $requiresAuth
        );

        // Read current content
        $content = File::get($this->routeFilePath);

        // Check if route already exists
        if (str_contains($content, "'{$routeName}'")) {
            return false; // Route already exists
        }

        // Add route to appropriate section
        if ($isFrontend) {
            // Add to frontend section
            $content = $this->addFrontendRoute($content, $routeDefinition);
        } else {
            // Add to admin section (existing behavior)
            $content = str_replace(
                '// {{ routes }}',
                $routeDefinition . "\n        // {{ routes }}",
                $content
            );
        }

        // Write back
        File::put($this->routeFilePath, $content);

        return true;
    }

    /**
     * Generate route definition.
     *
     * @param string $path
     * @param string $componentClass
     * @param string $name
     * @param array $middleware
     * @param string $permission
     * @param bool $isFrontend
     * @param bool $requiresAuth
     * @return string
     */
    protected function generateRouteDefinition(
        string $path,
        string $componentClass,
        string $name,
        array $middleware = [],
        string $permission = '',
        bool $isFrontend = false,
        bool $requiresAuth = true
    ): string {
        $middlewareStr = !empty($middleware) 
            ? "->middleware(['" . implode("', '", $middleware) . "'])" 
            : '';

        $permissionComment = $permission 
            ? " // Permission: {$permission}" 
            : '';
        
        $typeComment = $isFrontend ? ' [Frontend]' : ' [Admin]';
        $authComment = !$requiresAuth ? ' [No Auth]' : '';

        return <<<PHP

        // {$name} CRUD{$typeComment}{$authComment}{$permissionComment}
        Route::get('{$path}', {$componentClass}::class)
            ->name('{$name}'){$middlewareStr};
PHP;
    }

    /**
     * Remove a CRUD route from the route file.
     *
     * @param string $resourceName
     * @return bool
     */
    public function removeRoute(string $resourceName): bool
    {
        if (!$this->routeFileExists()) {
            return false;
        }

        $routeName = Str::kebab(Str::plural($resourceName));
        $content = File::get($this->routeFilePath);

        // Find and remove the route block
        $pattern = "/\n\s*\/\/ {$routeName} CRUD.*?\n\s*Route::get\(.*?\)->name\('{$routeName}'\).*?;/s";
        $content = preg_replace($pattern, '', $content);

        File::put($this->routeFilePath, $content);

        return true;
    }

    /**
     * Get all registered CRUD routes.
     *
     * @return array
     */
    public function getRegisteredRoutes(): array
    {
        if (!$this->routeFileExists()) {
            return [];
        }

        $content = File::get($this->routeFilePath);
        $routes = [];

        // Extract route names
        preg_match_all("/->name\('([^']+)'\)/", $content, $matches);

        if (!empty($matches[1])) {
            $routes = $matches[1];
        }

        return $routes;
    }

    /**
     * Regenerate the entire route file from discovered components.
     *
     * @param array $components
     * @return bool
     */
    public function regenerateRouteFile(array $components): bool
    {
        // Create fresh route file
        File::put($this->routeFilePath, $this->routeTemplate);

        // Add each component
        foreach ($components as $component) {
            $this->addRoute(
                $component['name'],
                $component['class'],
                $component['options'] ?? []
            );
        }

        return true;
    }

    /**
     * Check if a route is registered.
     *
     * @param string $resourceName
     * @return bool
     */
    public function isRouteRegistered(string $resourceName): bool
    {
        $routeName = Str::kebab(Str::plural($resourceName));
        $routes = $this->getRegisteredRoutes();

        return in_array($routeName, $routes);
    }

    /**
     * Get route file statistics.
     *
     * @return array
     */
    public function getStatistics(): array
    {
        return [
            'file_exists' => $this->routeFileExists(),
            'file_path' => $this->routeFilePath,
            'total_routes' => count($this->getRegisteredRoutes()),
            'routes' => $this->getRegisteredRoutes(),
            'file_size' => $this->routeFileExists() ? File::size($this->routeFilePath) : 0,
            'last_modified' => $this->routeFileExists() ? File::lastModified($this->routeFilePath) : null,
        ];
    }

    /**
     * Backup the current route file.
     *
     * @return string|null Path to backup file
     */
    public function backup(): ?string
    {
        if (!$this->routeFileExists()) {
            return null;
        }

        // Create backup directory in storage/app/private/routes
        $backupDir = storage_path('app/private/hyro/routes');
        if (!File::exists($backupDir)) {
            File::makeDirectory($backupDir, 0755, true);
        }

        // Generate backup filename with timestamp
        $backupFilename = 'crud_routes_backup_' . date('Y-m-d_His') . '.php';
        $backupPath = $backupDir . '/' . $backupFilename;

        // Copy route file to backup location
        File::copy($this->routeFilePath, $backupPath);

        return $backupPath;
    }

    /**
     * Restore from a backup file.
     *
     * @param string $backupPath
     * @return bool
     */
    public function restore(string $backupPath): bool
    {
        if (!File::exists($backupPath)) {
            return false;
        }

        $this->ensureRouteFileExists();
        File::copy($backupPath, $this->routeFilePath);

        return true;
    }

    /**
     * List all available backups.
     *
     * @return array
     */
    public function listBackups(): array
    {
        $backupDir = storage_path('app/private/hyro/routes');
        
        if (!File::exists($backupDir)) {
            return [];
        }

        $backups = [];
        $files = File::files($backupDir);

        foreach ($files as $file) {
            if (str_ends_with($file->getFilename(), '.php')) {
                $backups[] = [
                    'path' => $file->getPathname(),
                    'filename' => $file->getFilename(),
                    'size' => $file->getSize(),
                    'modified' => $file->getMTime(),
                    'modified_human' => date('Y-m-d H:i:s', $file->getMTime()),
                ];
            }
        }

        // Sort by modified time (newest first)
        usort($backups, function($a, $b) {
            return $b['modified'] - $a['modified'];
        });

        return $backups;
    }

    /**
     * Delete old backups, keeping only the specified number of recent backups.
     *
     * @param int $keep Number of backups to keep
     * @return int Number of backups deleted
     */
    public function cleanOldBackups(int $keep = 10): int
    {
        $backups = $this->listBackups();
        
        if (count($backups) <= $keep) {
            return 0;
        }

        $toDelete = array_slice($backups, $keep);
        $deleted = 0;

        foreach ($toDelete as $backup) {
            if (File::delete($backup['path'])) {
                $deleted++;
            }
        }

        return $deleted;
    }

    /**
     * Check if a route path is already taken.
     *
     * @param string $path
     * @return bool
     */
    protected function isRoutePathTaken(string $path): bool
    {
        if (!$this->routeFileExists()) {
            return false;
        }

        $content = File::get($this->routeFilePath);
        return str_contains($content, "Route::get('{$path}'");
    }

    /**
     * Generate an available route path by appending a number.
     *
     * @param string $basePath
     * @return string
     */
    protected function generateAvailableRoutePath(string $basePath): string
    {
        $counter = 1;
        $newPath = $basePath;

        while ($this->isRoutePathTaken($newPath)) {
            $newPath = $basePath . '-' . $counter;
            $counter++;
        }

        return $newPath;
    }

    /**
     * Add a frontend route to the route file.
     *
     * @param string $content
     * @param string $routeDefinition
     * @return string
     */
    protected function addFrontendRoute(string $content, string $routeDefinition): string
    {
        // Check if frontend section exists
        if (!str_contains($content, '// {{ frontend_routes }}')) {
            // Add frontend section before admin section
            $frontendSection = <<<'PHP'

/*
|--------------------------------------------------------------------------
| Frontend CRUD Routes
|--------------------------------------------------------------------------
|
| These routes are for frontend-facing CRUD interfaces.
| They are registered at the root level (not under admin prefix).
|
*/

Route::middleware(['web'])
    ->name('frontend.')
    ->group(function () {
        // Frontend CRUD routes will be auto-generated below
        // {{ frontend_routes }}
    });

PHP;
            
            // Insert before admin section
            $content = str_replace(
                'Route::prefix(config(\'hyro.admin.route.prefix\', \'admin/hyro\'))',
                $frontendSection . "\nRoute::prefix(config('hyro.admin.route.prefix', 'admin/hyro'))",
                $content
            );
        }

        // Add route to frontend section
        $content = str_replace(
            '// {{ frontend_routes }}',
            $routeDefinition . "\n        // {{ frontend_routes }}",
            $content
        );

        return $content;
    }
}
